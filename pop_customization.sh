#!/bin/bash

resDir="res"
colorCodes="$resDir/colorCodes"
refDir='Pop_Theme_reference'
modDir='Pop_Theme_modified'
colorsJson="$resDir/colors.json"

# Functions related to color output in terminal if -c option was provided

hexToRGB () {
	hex=$1
	printf "%d %d %d\n" 0x${hex:0:2} 0x${hex:2:2} 0x${hex:4:2}
}

getClosestColor () {
	ir=$1
	ig=$2
	ib=$3
	colors=`cat $colorsJson`
    max=`echo $colors | jq '. | length'`
	minOffset=765 #3x255
	declare -A colorArray
	for (( i=0; i<$max; i++ ))
	do	
		color=`echo $colors | jq ".[$i]"`
		r=`echo $color | jq ".rgb.r"`
		g=`echo $color | jq ".rgb.g"`
		b=`echo $color | jq ".rgb.b"`
		offsetR=$((ir-r))
		offsetG=$((ig-g))
		offsetB=$((ib-b))

		if [ $offsetR -lt 0 ] ; then offsetR=$((0-offsetR)) ; fi
		if [ $offsetG -lt 0 ] ; then offsetG=$((0-offsetG)) ; fi
		if [ $offsetB -lt 0 ] ; then offsetB=$((0-offsetB)) ; fi

		offset=$((offsetR+offsetG+offsetB))

		if [ $offset -le $minOffset ]
		then
			if [ ${colorArray[$offset]+_} ] 
			then colorArray["$offset"]+=", $color"
			else colorArray["$offset"]=$color
			fi
			minOffset=$offset
		fi
	done
	echo ${colorArray["$minOffset"]} | jq '.'
}

colorCodeCached () {
	code="-1"
	while read l ; do
		line=($l)
		if [ $1 == ${line[0]} ] ; then code=${line[1]} ; fi
	done < $colorCodes
	echo $code
}

getColorCode () {
	hex=$1
	code=0
	if [[ ${#hex} -eq 7 ]]
	then
		hex="${hex:1}"
		if [[ $hex =~ ^[0-9A-Fa-f]{6}$ ]]
		then
			touch $colorCodes
			code=`colorCodeCached $hex`
			if [ $code == "-1" ] 
			then
				rgb=(`hexToRGB $hex`)
				r=${rgb[0]}
				g=${rgb[1]}
				b=${rgb[2]}
				color=`getClosestColor $r $g $b`
				code=`echo $color | jq ".colorId"`
				echo "$hex $code" >> $colorCodes
			fi
		fi
	fi
    echo $code
}

# end of color output related functions

# Script parameters handling

d=false
i=false
r=false
c=false
w=false
man='Usage: pop_customization [OPTIONS] \nGenerates a Pop OS based theme with a custom color scheme. \n	-d	Force download of reference theme from Pop OS git repo.\n	-i	Install theme after customization\n	-r	Reset installed theme to vanilla Pop OS theme.\n	-h	Display this help and exit.\n	-c	Use terminal colors for preview (compatible with most modern terminals)\n	-w	Wipe local resources previously generated by the script'

if [ $# -ne 0 ]
then
	for arg in "$@"
	do
		case $arg in
		"-d")
			d=true
			;;
		"-i")
			i=true
			;;
		"-r")
			echo "-r isn't yet implemented"
			r=true
			exit
			;;
		"-h")
			echo -e $man
			exit
			;;
		"-c")
			c=true
			;;
		"-w")
			w=true
			;;
		*)
			echo "Unknown argument $arg"
			exit
			;;
		esac
	done
fi

if $w
then
	rm -r $refDir
	rm -r $resDir
fi

if [ ! -d $resDir ] ; then mkdir $resDir ; fi

if ! $d
then
	if [ ! -d $refDir ]
	then 
		echo "Reference theme not locally available, do you want to download it ? [Y/n]"
		read input
		case $input in
		"y"|"yes"|""|"Yes"|"Y")
			d=true
			;;
		*)
			exit
			;;
		esac
	fi
fi

if $d 
then
	echo "Get official Pop OS theme from git repo." 
	rm -r $refDir
	git clone https://github.com/pop-os/gtk-theme.git $refDir
fi

if $c
then
	echo -e "\n\033[01;01mDisclaimer : \033[00m"
	echo -e "\033[01;01mMost terminals have only 256 colors\033[00m"
	echo -e "\033[01;01mYour screen has more (I hope for you)\033[00m"
	echo -e "\033[01;01mColors displayed here will only be an approximation\033[00m\n"
	echo -e "\033[01;01mParsing TermX color codes will take a while on the first run, but once cached it'll be faster on subsequent runs\033[00m\n"
	if ! [ -f $colorsJson ]
	then
		echo "Reference color codes not locally available, do you want to download them ? [Y/n]"
		read input
		case $input in
		"y"|"yes"|""|"Yes"|"Y")
			curl https://jonasjacek.github.io/colors/data.json | jq . > $colorsJson
			;;
		*)
			echo "Won't use colors"
			c=false
			;;
		esac
	fi
fi

# End of script parameter handling

count=0
while read l; do
	((count++))
	print=false
	dark=false
	case $l in
	*"- Orange:"*)
		color="Orange: "
		;;
	*"- Blue:"*)
		color="Blue: "
		;;
	*"- Window background:"*)
		color="Window Background: "
		;;
	*"- Header/Title Bars:"*)
		color="Header/Title Bars: "
		;;
	*"- Dark theme:"*)
		dark=true
		words=($l)
		#echo "color 1: ${words[3]}, color 2: ${words[5]}"
		;;
	*"- Light theme:"*)
		words=($l)
		#echo "color 1: ${words[3]}, color 2: ${words[5]}"
		;;
	esac
done < $refDir/TESTING.md

echo -e "Copy theme directory to $modDir where modifications will happen.\n"
cp -r $refDir $modDir

formatHex () {
	li=${1#*#}
	echo "#${li:0:6}"
}

formatColors () {
	if $c
	then
		codeLight=`getColorCode $2`
		codeDark=`getColorCode $3`
		echo "$1 \033[01;38;5;${codeLight}m$2\033[00m \033[01;38;5;${codeDark}m$3\033[00m"
	else
		echo "$1 $2 $3"
	fi
}

# Parsing colors from /gnome-shell/src/gnome-shell-sass/_colors.scss 

echo -e "\033[01;01mLet's extract colors used in gnome-shell theme\033[00m\n"

shellColors="/gnome-shell/src/gnome-shell-sass/_colors.scss"
baseColorsArray=("\$base_color" "\$bg_color" "\$fg_color")
declare -A baseColorsMap
for color in ${baseColorsArray[*]}
do
	baseColorsMap[$color,0]="#000000"
	baseColorsMap[$color,1]="#000000"
done

while read l; do
	words=($l)
	for color in ${baseColorsArray[*]}
	do
		if [[ $l == *"$color:"* ]]
		then
			baseColorsMap[$color,0]=`formatHex ${words[4]}`
			baseColorsMap[$color,1]=`formatHex ${words[5]}`
		fi
	done
done < $refDir$shellColors

displayBaseColors () {
	size=${#baseColorsMap[@]}
	count=1
	for color in ${baseColorsArray[*]}
	do
		echo -ne "Parsing base color code $count of $size"\\r 1>&2
		echo -e `formatColors "$color" ${baseColorsMap[$color,0]} ${baseColorsMap[$color,1]}`
		(( count++ ))	
		(( count++ ))
	done
}

# End of color parsing from /gnome-shell/src/gnome-shell-sass/_colors.scss 

# Parsing colors from /gnome-shell/src/gnome-shell-sass/_pop_os_colors.scss 

popOsColors="/gnome-shell/src/gnome-shell-sass/_pop_os_colors.scss"
popColorsArray=("orange" "blue" "green" "red" "yellow" "purple" "pink" "indigo")
variants=("\$" "\$highlights_" "\$text_")
warmGreysArray=("#000000" "#000000" "#000000")
uiColorsArray=("_ui_100" "_ui_300" "_ui_500" "_ui_700" "_ui_900")
gdmGrey="#000000"

declare -A popColorsMap
for color in ${popColorsArray[*]}
do
	for variant in ${variants[*]}
	do 
		popColorsMap[$color,$variant,0]="#000000"
		popColorsMap[$color,$variant,1]="#000000"
	done
done

declare -A uiColorsMap
for color in ${uiColorsArray[*]}
do
	uiColorsMap[$color,0]="#000000"
	uiColorsMap[$color,1]="#000000"
done

extractPopColors () {
	words=($1)
	for color in ${popColorsArray[*]}
	do
		for variant in ${variants[*]}
		do
			if [[ $1 == *"$variant$color"* ]]
			then
				popColorsMap[$color,$variant,0]=`formatHex ${words[2]}`
				popColorsMap[$color,$variant,1]=`formatHex ${words[3]}`
			fi
		done
	done
}

extractWarmGreys () {
	words=($1)
	case $1 in
	*"\$light_warm_grey"*)
		warmGreysArray[0]=`formatHex ${words[1]}`
		;;
	*"\$dark_warm_grey"*)
		warmGreysArray[1]=`formatHex ${words[1]}`
		;;
	*"\$warm_grey"*)
		warmGreysArray[2]=`formatHex ${words[1]}`
		;;
	esac
}

extractUIColors () {
	words=($1)
	for color in ${uiColorsArray[*]}
	do
		if [[ $1 == *"\$light$color:"* ]]
		then
			uiColorsMap[$color,0]=`formatHex ${words[1]}`
		fi
		if [[ $1 == *"\$dark$color:"* ]]
		then
			uiColorsMap[$color,1]=`formatHex ${words[1]}`
		fi
	done
}

extractGDMGrey () {
	words=($1)
	if [[ $1 == *"\$gdm_grey:"* ]]
	then
		gdmGrey=`formatHex ${words[1]}`
	fi
}

displayPopColors () {	
	size=${#popColorsMap[@]}
	count=1
	for color in ${popColorsArray[*]}
	do
		for variant in ${variants[*]}
		do
			echo -ne "Parsing pop color code $count of $size"\\r 1>&2
			echo -e `formatColors "$variant$color" ${popColorsMap[$color,$variant,0]} ${popColorsMap[$color,$variant,1]}`
			(( count++ ))
			(( count++ ))
		done
	done
}

displayWarmGreys () {
	if $c
	then
		codeLight=`getColorCode ${warmGreysArray[0]}`
		codeDark=`getColorCode ${warmGreysArray[1]}`
		codeNeutral=`getColorCode ${warmGreysArray[2]}`
		echo -e "\$warm_grey \033[01;38;5;${codeLight}m${warmGreysArray[0]}\033[00m \033[01;38;5;${codeDark}m${warmGreysArray[1]}\033[00m \033[01;38;5;${codeNeutral}m${warmGreysArray[2]}\033[00m"
	else
		echo "\$warm_grey ${warmGreysArray[0]} ${warmGreysArray[1]} ${warmGreysArray[2]}"
	fi
}

displayUIColors () {
	size=${#uiColorsMap[@]}
	count=1
	for color in ${uiColorsArray[*]}
	do
		echo -ne "Parsing UI color code $count of $size"\\r 1>&2
		echo -e `formatColors "$color" ${uiColorsMap[$color,0]} ${uiColorsMap[$color,1]}`
			(( count++ ))
			(( count++ ))
	done
}

displayGDMColor () {
	if $c
	then
		codeNeutral=`getColorCode $gdmGrey`
		echo -e "\$gdm_grey [_____] [_____] \033[01;38;5;${codeNeutral}m$gdmGrey\033[00m"
	else
		echo "\$gdm_grey \t \t $gdmGrey"
	fi
}

while read l || [ -n "$l" ]
do
	extractPopColors "$l" 
	extractWarmGreys "$l"
	extractUIColors "$l"
	extractGDMGrey "$l"
done < $refDir$popOsColors

# End of color parsing from /gnome-shell/src/gnome-shell-sass/_pop_os_colors.scss 

display () {
	echo -e 'Colors Light Dark Neutral'	
	echo -e "\033[01;01m_colors.scss\033[00m"
	displayBaseColors
	echo -e "\033[01;01m_pop_os_colors.scss\033[00m"
	displayPopColors
	displayWarmGreys
	displayUIColors
	displayGDMColor
}

display | column -t

